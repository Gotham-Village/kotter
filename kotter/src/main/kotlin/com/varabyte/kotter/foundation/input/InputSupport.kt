package com.varabyte.kotter.foundation.input

import com.varabyte.kotter.foundation.anim.Anim
import com.varabyte.kotter.foundation.anim.TextAnim
import com.varabyte.kotter.foundation.text.*
import com.varabyte.kotter.foundation.timer.addTimer
import com.varabyte.kotter.runtime.MainRenderScope
import com.varabyte.kotter.runtime.RunScope
import com.varabyte.kotter.runtime.Session
import com.varabyte.kotter.runtime.Section
import com.varabyte.kotter.runtime.concurrent.ConcurrentScopedData
import com.varabyte.kotter.runtime.concurrent.createKey
import com.varabyte.kotter.runtime.internal.ansi.Ansi
import com.varabyte.kotter.runtime.terminal.Terminal
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import java.time.Duration

/**
 * Lifecycle associated with the `input()` function.
 *
 * Normally this is the same as the section lifecycle, but occasionally the same section can call `input()` multiple
 * times in a row, at which point it should be cleared between each call.
 */
private object InputLifecycle : ConcurrentScopedData.Lifecycle {
    override val parent = Section.Lifecycle
}

// Once created, we keep it alive for the session, because Flow is designed to be collected multiple times, meaning
// there's no reason for us to keep recreating it. It's pretty likely that if a session uses input in one block, it
// will use input again in others. (We can always revisit this decision later and scope this to a Section lifecycle
// instead)
private val KeyFlowKey = Session.Lifecycle.createKey<Flow<Key>>()

/**
 * Create a [Flow<Key>] value which converts bytes read from a terminal into keys, handling some gnarly multi-byte
 * cases and smoothing over other inconsistent, historical legacy.
 */
private fun ConcurrentScopedData.prepareKeyFlow(terminal: Terminal) {
    start(InputLifecycle)

    tryPut(KeyFlowKey) {
        val escSeq = StringBuilder()
        channelFlow {
            terminal.read().collect { byte ->
                val c = byte.toChar()
                val key = when {
                    escSeq.isNotEmpty() -> {
                        escSeq.append(c)
                        val code = Ansi.EscSeq.toCode(escSeq)
                        if (code != null) {
                            escSeq.clear()
                            when (code) {
                                Ansi.Csi.Codes.Keys.UP -> Keys.UP
                                Ansi.Csi.Codes.Keys.DOWN -> Keys.DOWN
                                Ansi.Csi.Codes.Keys.LEFT -> Keys.LEFT
                                Ansi.Csi.Codes.Keys.RIGHT -> Keys.RIGHT
                                Ansi.Csi.Codes.Keys.HOME, Ansi.Csi.Codes.Cursor.MOVE_TO_LINE_START -> Keys.HOME
                                Ansi.Csi.Codes.Keys.INSERT -> Keys.INSERT
                                Ansi.Csi.Codes.Keys.DELETE -> Keys.DELETE
                                Ansi.Csi.Codes.Keys.END, Ansi.Csi.Codes.Cursor.MOVE_TO_LINE_END -> Keys.END
                                Ansi.Csi.Codes.Keys.PG_UP -> Keys.PAGE_UP
                                Ansi.Csi.Codes.Keys.PG_DOWN -> Keys.PAGE_DOWN
                                else -> null
                            }
                        } else {
                            null
                        }
                    }
                    else -> {
                        when (c) {
                            Ansi.CtrlChars.EOF -> Keys.EOF
                            // Windows uses BACKSPACE, *nix uses DELETE? Best to support both
                            Ansi.CtrlChars.BACKSPACE, Ansi.CtrlChars.DELETE -> Keys.BACKSPACE
                            Ansi.CtrlChars.TAB -> Keys.TAB
                            Ansi.CtrlChars.ENTER -> Keys.ENTER
                            Ansi.CtrlChars.ESC -> {
                                escSeq.append(c)
                                // This is kind of ugly but we need to detect the difference between the user pressing
                                // ESC on their own vs it being the first character in a chain of an escape sequence
                                // generated by the terminal. If the terminal generates an escape sequence, the whole
                                // thing is consumed sub millisecond, so waiting a couple dozen ms to be sure we aren't
                                // getting any followup characters.
                                CoroutineScope(Dispatchers.IO).launch {
                                    delay(50)
                                    if (escSeq.isNotEmpty()) {
                                        if (escSeq.length == 1) {
                                            send(Keys.ESC)
                                        }
                                        escSeq.clear()
                                    }
                                }

                                null
                            }
                            else -> if (!c.isISOControl()) CharKey(c) else null
                        }
                    }
                }

                if (key != null) {
                    send(key)
                }
            }
        }
            // We only want to collect keypresses in one place per session. Use shareIn so collecters don't spawn new
            // flows. For example, multiple flows here would really mess with the escSeq logic
            .shareIn(CoroutineScope(Dispatchers.IO), SharingStarted.Lazily)
    }
}

/** State needed to support the `input()` function */
private class InputState {
    object Key : ConcurrentScopedData.Key<InputState> {
        override val lifecycle = InputLifecycle
    }
    companion object {
        private const val BLINKING_DURATION_MS = 500
    }

    var id: Any? = null

    var text = ""
        set(value) {
            if (field != value) {
                field = value
                resetCursor()
            }
        }
    var index = 0
        set(value) {
            if (field != value) {
                field = value
                resetCursor()
            }
        }
    var blinkOn = true
    var blinkElapsedMs = 0

    private fun resetCursor() {
        blinkOn = true
        blinkElapsedMs = 0
    }

    /** Elapse the timer on this input state's cursor animation, returning true if the cursor actually changed. */
    fun elapse(duration: Duration): Boolean {
        val prevBlinkOn = blinkOn
        blinkElapsedMs += duration.toMillis().toInt()
        while (blinkElapsedMs > BLINKING_DURATION_MS) {
            blinkElapsedMs -= BLINKING_DURATION_MS
            blinkOn = !blinkOn
        }
        return prevBlinkOn != blinkOn
    }
}

private val OnlyCalledOncePerRenderKey = MainRenderScope.Lifecycle.createKey<Unit>()
private val UpdateInputJobKey = InputLifecycle.createKey<Job>()

/**
 * If necessary, instantiate data that the [input] method expects to exist.
 *
 * Is a no-op after the first time.
 */
private fun ConcurrentScopedData.prepareInput(scope: MainRenderScope) {
    if (!tryPut(OnlyCalledOncePerRenderKey) { }) {
        throw IllegalStateException("Calling `input` more than once in a render pass is not supported")
    }

    val section = scope.section
    prepareKeyFlow(section.session.terminal)
    var stopTimer = false
    if (tryPut(InputState.Key, { InputState() }, { stopTimer = true })) {
        section.onRendered {
            if (get(OnlyCalledOncePerRenderKey) == null) {
                // input() was not called this frame. We can safely clear its resources.
                stop(InputLifecycle)

                // We don't need this listener anymore
                removeListener = true
            }
        }

        val state = get(InputState.Key)!!
        addTimer(Anim.ONE_FRAME_60FPS, repeat = true) {
            if (state.elapse(elapsed)) {
                section.requestRerender()
            }
            if (stopTimer) {
                repeat = false
            }
        }
        section.onFinishing {
            if (state.blinkOn) {
                state.blinkOn = false
                section.requestRerender()
            }
        }
    }
    tryPut(
        UpdateInputJobKey,
        provideInitialValue = {
            CoroutineScope(Dispatchers.IO).launch {
                getValue(KeyFlowKey).collect { key ->
                    get(InputState.Key) {
                        val prevText = text
                        val prevIndex = index
                        var proposedText: String? = null
                        var proposedIndex: Int? = null
                        when (key) {
                            Keys.LEFT -> index = (index - 1).coerceAtLeast(0)
                            Keys.RIGHT -> {
                                if (index < text.length) {
                                    index++
                                }
                                else {
                                    get(CompleterKey) {
                                        complete(text)?.let { completion ->
                                            val finalText = text + completion
                                            proposedText = finalText
                                            proposedIndex = finalText.length
                                        }
                                    }
                                }
                            }
                            Keys.HOME -> index = 0
                            Keys.END -> index = text.length
                            Keys.DELETE -> {
                                if (index <= text.lastIndex) {
                                    proposedText = text.removeRange(index, index + 1)
                                }
                            }

                            Keys.BACKSPACE -> {
                                if (index > 0) {
                                    proposedText = text.removeRange(index - 1, index)
                                    proposedIndex = index - 1
                                }
                            }

                            Keys.ENTER -> {
                                var rejected = false
                                get(InputEnteredCallbackKey) {
                                    val onInputEnteredScope = OnInputEnteredScope(text)
                                    this.invoke(onInputEnteredScope)
                                    rejected = onInputEnteredScope.rejected
                                }
                                if (!rejected) {
                                    get(SystemInputEnteredCallbackKey) { this.invoke() }
                                }
                            }
                            else ->
                                if (key is CharKey) {
                                    proposedText = "${text.take(index)}${key.code}${text.takeLast(text.length - index)}"
                                    proposedIndex = index + 1
                                }
                        }

                        if (proposedText != null) {
                            get(InputChangedCallbacksKey) {
                                val onInputChangedScope = OnInputChangedScope(input = proposedText!!, prevInput = text)
                                forEach { callback -> onInputChangedScope.callback() }

                                proposedText = if (!onInputChangedScope.rejected) onInputChangedScope.input else onInputChangedScope.prevInput
                            }

                            text = proposedText!!
                            index = (proposedIndex ?: index).coerceIn(0, text.length)
                        }

                        if (text != prevText || index != prevIndex) {
                            section.requestRerender()
                        }
                    }
                }
            }
        },
        dispose = { job -> job.cancel() }
    )
}

interface InputCompleter {
    /**
     * Given some [input], return a suffix that should complete it, or null if the string does not have a matching
     * completion.
     *
     * For example, for "y", you might return "es"
     */
    fun complete(input: String): String?

    val color: Color get() = Color.BRIGHT_BLACK
}

/**
 * A default [InputCompleter] that provides completions given a list of values.
 *
 * If there are multiple matches, e.g. "Colorado" and "Connecticut" for "co", the item earlier in the list will be
 * suggested as the completion.
 */
open class Completions(private vararg val values: String, private val ignoreCase: Boolean = true) : InputCompleter {
    override fun complete(input: String): String? {
        return values.firstOrNull { value ->
            value.startsWith(input, ignoreCase)
        }?.substring(input.length)
    }
}

private val CompleterKey = InputLifecycle.createKey<InputCompleter>()

/**
 * A function which, when called, will replace itself dynamically with some input text plus a blinking cursor.
 *
 * You can only call `input()` ONCE each render pass - if you call it twice, you'll get a runtime exception.
 *
 * You can use the `onInputChanged` and `onInputEntered` callbacks to query the value as the user types it / commits it.
 *
 * ```
 * section {
 *   text("Enter your name: "); input()
 * }.run {
 *   onInputEntered {
 *     // here, "input" is what the user typed in
 *   }
 * }
 * ```
 *
 * An optional ID can be passed if for the (fairly rare?) case where you might have a conditional switch where each
 * branch calls `input()`:
 *
 * ```
 * when (state) {
 *   ASK_NAME -> text("Your name? "); input(id = "name")
 *   ASK_AGE -> text("Your age? "); input(id = "age")
 *   ...
 * }
 * ```
 *
 * Usually you would do this in separate sections, but perhaps you want to cycle through questions within the same
 * section for a particular UX feel.
 *
 * Without IDs, any input you typed into the first block would carry over to the second, because we can't tell the
 * difference between calls, but by passing in an ID for each case, we can understand that we're being triggered by a
 * new call.
 *
 * @param completer Optional logic for suggesting auto-completions based on what the user typed in. See
 *   [Completions] which is a generally useful and common implementation.
 * @param initialText Text which will be used the first time `input()` is called and ignored subsequently.
 * @param id See docs above for more details. The value of this parameter can be anything - this method simply does an
 *   equality check on it with a previous value.
 */
fun MainRenderScope.input(completer: InputCompleter? = null, initialText: String = "", id: Any = Unit) {
    data.prepareInput(this)
    completer?.let { data[CompleterKey] = it }

    data.get(InputState.Key) {
        if (this.id != id) {
            this.id = id
            text = initialText
            index = initialText.length
        }

        val completion = completer?.complete(text) ?: ""
        // Note: Trailing space as cursor can be put AFTER last character
        val finalText = "$text$completion "

        scopedState { // Make sure color changes don't leak
            for (i in finalText.indices) {
                if (i == text.length && completer != null && completion.isNotEmpty()) {
                    color(completer.color)
                }
                if (i == index && blinkOn) {
                    invert()
                }
                text(finalText[i])
                if (i == index && blinkOn) {
                    clearInvert()
                }
            }
        }
    }
}

class OnKeyPressedScope(val key: Key)

private val KeyPressedJobKey = RunScope.Lifecycle.createKey<Job>()
private val KeyPressedCallbackKey = RunScope.Lifecycle.createKey<OnKeyPressedScope.() -> Unit>()
// Note: We create a separate key here from above to ensure we can trigger the system callback only AFTER the user
// callback was triggered. That's because the system handler may fire a signal which, if sent out too early, could
// result in the user callback not getting a chance to run.
private val SystemKeyPressedCallbackKey = RunScope.Lifecycle.createKey<OnKeyPressedScope.() -> Unit>()

/**
 * Start running a job that collects keypresses and sends them to callbacks.
 *
 * This is a no-op when called after the first time.
 */
private fun ConcurrentScopedData.prepareOnKeyPressed(terminal: Terminal) {
    prepareKeyFlow(terminal)
    tryPut(
        KeyPressedJobKey,
        provideInitialValue = {
            CoroutineScope(Dispatchers.IO).launch {
                getValue(KeyFlowKey).collect { key ->
                    val scope = OnKeyPressedScope(key)
                    get(KeyPressedCallbackKey) { this.invoke(scope) }
                    get(SystemKeyPressedCallbackKey) { this.invoke(scope) }
                }
            }
        },
        dispose = { job -> job.cancel() }
    )
}

fun RunScope.onKeyPressed(listener: OnKeyPressedScope.() -> Unit) {
    data.prepareOnKeyPressed(section.session.terminal)
    if (!data.tryPut(KeyPressedCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onKeyPressed` callback at a time is supported.")
    }
}

fun Section.runUntilKeyPressed(vararg keys: Key, block: suspend RunScope.() -> Unit = {}) {
    run {
        data.prepareOnKeyPressed(this.section.session.terminal)
        data[SystemKeyPressedCallbackKey] = { if (keys.contains(key)) abort() }
        block()
        CompletableDeferred<Unit>().await() // The only way out of this function is by aborting
    }
}

class OnInputChangedScope(var input: String, val prevInput: String) {
    internal var rejected = false
    fun rejectInput() { rejected = true }
}
private val InputChangedCallbacksKey = RunScope.Lifecycle.createKey<MutableList<OnInputChangedScope.() -> Unit>>()

fun RunScope.onInputChanged(listener: OnInputChangedScope.() -> Unit) {
    data.putIfAbsent(InputChangedCallbacksKey, provideInitialValue = { mutableListOf() }) { add(listener) }
}

class OnInputEnteredScope(val input: String) {
    internal var rejected = false
    fun rejectInput() { rejected = true }
}
private val InputEnteredCallbackKey = RunScope.Lifecycle.createKey<OnInputEnteredScope.() -> Unit>()

// Note: We create a separate key here from above to ensure we can trigger the system callback only AFTER the user
// callback was triggered. That's because the system handler may fire a signal which, if sent out too early, could
// result in the user callback not getting a chance to run.
private object SystemInputEnteredCallbackKey : ConcurrentScopedData.Key<() -> Unit> {
    override val lifecycle = RunScope.Lifecycle
}

fun RunScope.onInputEntered(listener: OnInputEnteredScope.() -> Unit) {
    if (!data.tryPut(InputEnteredCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onInputEntered` callback at a time is supported.")
    }
}

fun Section.runUntilInputEntered(block: suspend RunScope.() -> Unit = {}) {
    run {
        data[SystemInputEnteredCallbackKey] = { abort() }
        block()
        CompletableDeferred<Unit>().await() // The only way out of this function is by aborting
    }
}
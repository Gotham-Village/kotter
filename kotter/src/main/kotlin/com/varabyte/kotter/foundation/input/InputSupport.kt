package com.varabyte.kotter.foundation.input

import com.varabyte.kotter.foundation.anim.Anim
import com.varabyte.kotter.foundation.text.*
import com.varabyte.kotter.foundation.timer.addTimer
import com.varabyte.kotter.runtime.MainRenderScope
import com.varabyte.kotter.runtime.RunScope
import com.varabyte.kotter.runtime.Session
import com.varabyte.kotter.runtime.Section
import com.varabyte.kotter.runtime.concurrent.ConcurrentScopedData
import com.varabyte.kotter.runtime.concurrent.createKey
import com.varabyte.kotter.runtime.internal.ansi.Ansi
import com.varabyte.kotter.runtime.terminal.Terminal
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import java.time.Duration
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

// Once created, we keep it alive for the session, because Flow is designed to be collected multiple times, meaning
// there's no reason for us to keep recreating it. It's pretty likely that if a session uses input in one block, it
// will use input again in others. (We can always revisit this decision later and scope this to a Section lifecycle
// instead)
private val KeyFlowKey = Session.Lifecycle.createKey<Flow<Key>>()

/**
 * Create a [Flow<Key>] value which converts bytes read from a terminal into keys, handling some gnarly multi-byte
 * cases and smoothing over other inconsistent, historical legacy.
 */
private fun ConcurrentScopedData.prepareKeyFlow(terminal: Terminal) {
    tryPut(KeyFlowKey) {
        val keyLock = ReentrantLock()
        val escSeq = StringBuilder()
        var lastKeyTime: Long
        channelFlow {
            terminal.read().collect { byte ->
                val c = byte.toChar()
                val key = keyLock.withLock {
                    lastKeyTime = System.currentTimeMillis()
                    when {
                        escSeq.isNotEmpty() -> {
                            escSeq.append(c)
                            val code = Ansi.EscSeq.toCode(escSeq)
                            if (code != null) {
                                escSeq.clear()
                                when (code) {
                                    Ansi.Csi.Codes.Keys.UP -> Keys.UP
                                    Ansi.Csi.Codes.Keys.DOWN -> Keys.DOWN
                                    Ansi.Csi.Codes.Keys.LEFT -> Keys.LEFT
                                    Ansi.Csi.Codes.Keys.RIGHT -> Keys.RIGHT
                                    Ansi.Csi.Codes.Keys.HOME, Ansi.Csi.Codes.Cursor.MOVE_TO_LINE_START -> Keys.HOME
                                    Ansi.Csi.Codes.Keys.INSERT -> Keys.INSERT
                                    Ansi.Csi.Codes.Keys.DELETE -> Keys.DELETE
                                    Ansi.Csi.Codes.Keys.END, Ansi.Csi.Codes.Cursor.MOVE_TO_LINE_END -> Keys.END
                                    Ansi.Csi.Codes.Keys.PG_UP -> Keys.PAGE_UP
                                    Ansi.Csi.Codes.Keys.PG_DOWN -> Keys.PAGE_DOWN
                                    else -> null
                                }
                            } else {
                                null
                            }
                        }
                        else -> {
                            when (c) {
                                Ansi.CtrlChars.EOF -> Keys.EOF
                                // Windows uses BACKSPACE, *nix uses DELETE? Best to support both
                                Ansi.CtrlChars.BACKSPACE, Ansi.CtrlChars.DELETE -> Keys.BACKSPACE
                                Ansi.CtrlChars.TAB -> Keys.TAB
                                Ansi.CtrlChars.ENTER -> Keys.ENTER
                                Ansi.CtrlChars.ESC -> {
                                    escSeq.append(c)
                                    // This is kind of ugly but we need to detect the difference between the user pressing
                                    // ESC on their own vs it being the first character in a chain of an escape sequence
                                    // generated by the terminal. If the terminal generates an escape sequence, the whole
                                    // thing is consumed sub millisecond, so waiting a couple dozen ms to be sure we aren't
                                    // getting any followup characters. Note that a user can hold the keys down which
                                    // generates a bunch of key signals, so we additionally make sure there hasn't been
                                    // any other key pressed
                                    CoroutineScope(Dispatchers.IO).launch {
                                        val delayMs = 50L
                                        var doneWaiting = false
                                        var sendEsc = false
                                        while (!doneWaiting) {
                                            delay(10L)
                                            keyLock.withLock {
                                                if (System.currentTimeMillis() - lastKeyTime > delayMs) {
                                                    sendEsc = escSeq.length == 1 && escSeq.contains(Ansi.CtrlChars.ESC)
                                                    if (sendEsc) escSeq.clear()
                                                    doneWaiting = true
                                                }
                                            }
                                        }
                                        if (sendEsc) send(Keys.ESC)
                                    }
                                    null
                                }
                                else -> if (!c.isISOControl()) CharKey(c) else null
                            }
                        }
                    }
                }

                if (key != null) {
                    send(key)
                }
            }
        }
            // We only want to collect keypresses in one place per session. Use shareIn so collecters don't spawn new
            // flows. For example, multiple flows here would really mess with the escSeq logic
            .shareIn(CoroutineScope(Dispatchers.IO), SharingStarted.Lazily)
    }
}

/** State needed to support the `input()` function */
private class InputState {
    companion object {
        val Key = Section.Lifecycle.createKey<InputState>()
        private const val BLINKING_DURATION_MS = 500
    }

    var id: Any? = null

    var text = ""
        set(value) {
            if (field != value) {
                field = value
                resetCursor()
            }
        }
    var index = 0
        set(value) {
            if (field != value) {
                field = value
                resetCursor()
            }
        }
    var blinkOn = true
    var blinkElapsedMs = 0

    private fun resetCursor() {
        blinkOn = true
        blinkElapsedMs = 0
    }

    /** Elapse the timer on this input state's cursor animation, returning true if the cursor actually changed. */
    fun elapse(duration: Duration): Boolean {
        val prevBlinkOn = blinkOn
        blinkElapsedMs += duration.toMillis().toInt()
        while (blinkElapsedMs > BLINKING_DURATION_MS) {
            blinkElapsedMs -= BLINKING_DURATION_MS
            blinkOn = !blinkOn
        }
        return prevBlinkOn != blinkOn
    }
}

private val OnlyCalledOncePerRenderKey = MainRenderScope.Lifecycle.createKey<Unit>()
private val UpdateInputJobKey = Section.Lifecycle.createKey<Job>()

/**
 * If necessary, instantiate data that the [input] method expects to exist.
 *
 * Is a no-op after the first time.
 */
private fun ConcurrentScopedData.prepareInput(scope: MainRenderScope) {
    if (!tryPut(OnlyCalledOncePerRenderKey) { }) {
        throw IllegalStateException("Calling `input` more than once in a render pass is not supported")
    }

    val section = scope.section
    prepareKeyFlow(section.session.terminal)
    var suspended = false
    if (tryPut(InputState.Key) { InputState() }) {
        val state = get(InputState.Key)!!
        fun startInputTimer() {
            addTimer(Anim.ONE_FRAME_60FPS, repeat = true, key = state) {
                if (state.elapse(elapsed)) {
                    section.requestRerender()
                }
                if (suspended) {
                    repeat = false
                }
            }
        }

        section.onRendered {
            if (get(OnlyCalledOncePerRenderKey) == null) {
                // input() was not called this frame, so we can clear the blinker and pause the timer for now
                suspended = true
                state.blinkOn = false
            } else {
                // input() was called again after a few frames of being dormant
                if (suspended) {
                    startInputTimer()
                    suspended = false
                }
            }
        }

        section.onFinishing {
            if (state.blinkOn) {
                state.blinkOn = false
                section.requestRerender()
            }
        }
    }
    tryPut(
        UpdateInputJobKey,
        provideInitialValue = {
            CoroutineScope(Dispatchers.IO).launch {
                getValue(KeyFlowKey).collect { key ->
                    if (suspended) return@collect

                    get(InputState.Key) {
                        val prevText = text
                        val prevIndex = index
                        var proposedText: String? = null
                        var proposedIndex: Int? = null
                        when (key) {
                            Keys.LEFT -> index = (index - 1).coerceAtLeast(0)
                            Keys.RIGHT -> {
                                if (index < text.length) {
                                    index++
                                }
                                else {
                                    get(CompleterKey) {
                                        complete(text)?.let { completion ->
                                            val finalText = text + completion
                                            proposedText = finalText
                                            proposedIndex = finalText.length
                                        }
                                    }
                                }
                            }
                            Keys.HOME -> index = 0
                            Keys.END -> index = text.length
                            Keys.DELETE -> {
                                if (index <= text.lastIndex) {
                                    proposedText = text.removeRange(index, index + 1)
                                }
                            }

                            Keys.BACKSPACE -> {
                                if (index > 0) {
                                    proposedText = text.removeRange(index - 1, index)
                                    proposedIndex = index - 1
                                }
                            }

                            Keys.ENTER -> {
                                var rejected = false
                                var cleared = false
                                get(InputEnteredCallbackKey) {
                                    val onInputEnteredScope = OnInputEnteredScope(text)
                                    this.invoke(onInputEnteredScope)
                                    rejected = onInputEnteredScope.rejected
                                    cleared = onInputEnteredScope.cleared
                                }
                                if (!rejected) {
                                    get(SystemInputEnteredCallbackKey) { this.invoke() }
                                }
                                if (cleared) {
                                    proposedText = ""
                                    proposedIndex = 0
                                }
                            }
                            else ->
                                if (key is CharKey) {
                                    proposedText = "${text.take(index)}${key.code}${text.takeLast(text.length - index)}"
                                    proposedIndex = index + 1
                                }
                        }

                        if (proposedText != null) {
                            get(InputChangedCallbacksKey) {
                                val onInputChangedScope = OnInputChangedScope(input = proposedText!!, prevInput = text)
                                forEach { callback -> onInputChangedScope.callback() }

                                proposedText = if (!onInputChangedScope.rejected) onInputChangedScope.input else onInputChangedScope.prevInput
                            }

                            text = proposedText!!
                            index = (proposedIndex ?: index).coerceIn(0, text.length)
                        }

                        if (text != prevText || index != prevIndex) {
                            section.requestRerender()
                        }
                    }
                }
            }
        },
        dispose = { job -> job.cancel() }
    )
}

interface InputCompleter {
    /**
     * Given some [input], return a suffix that should complete it, or null if the string does not have a matching
     * completion.
     *
     * For example, for "y", you might return "es"
     */
    fun complete(input: String): String?

    val color: Color get() = Color.BRIGHT_BLACK
}

/**
 * A default [InputCompleter] that provides completions given a list of values.
 *
 * If there are multiple matches, e.g. "Colorado" and "Connecticut" for "co", the item earlier in the list will be
 * suggested as the completion.
 */
open class Completions(private vararg val values: String, private val ignoreCase: Boolean = true) : InputCompleter {
    override fun complete(input: String): String? {
        return values.firstOrNull { value ->
            value.startsWith(input, ignoreCase)
        }?.substring(input.length)
    }
}

private val CompleterKey = Section.Lifecycle.createKey<InputCompleter>()

/**
 * A function which, when called, will replace itself dynamically with some input text plus a blinking cursor.
 *
 * You can only call `input()` ONCE each render pass - if you call it twice, you'll get a runtime exception.
 *
 * You can use the `onInputChanged` and `onInputEntered` callbacks to query the value as the user types it / commits it.
 *
 * ```
 * section {
 *   text("Enter your name: "); input()
 * }.run {
 *   onInputEntered {
 *     // here, "input" is what the user typed in
 *   }
 * }
 * ```
 *
 * Occasionally, you may call `input` across multiple cases:
 *
 * ```
 * when (state) {
 *   ASK_NAME -> text("Your name? "); input(id = "name")
 *   ASK_AGE -> text("Your age? "); input(id = "age")
 *   ...
 * }
 * ```
 *
 * Usually you would do this in separate sections, but perhaps you want to cycle through questions within the same
 * section for a particular UX feel.
 *
 * You can acomplish this two ways. One, pass in an ID for each input call, or call `clearInput` on `onInputEntered`.
 *
 * Approach #1, using IDs:
 * ```
 * when (state) {
 *   ASK_NAME -> text("Your name? "); input(id = "name")
 *   ASK_AGE -> text("Your age? "); input(id = "age")
 *   ...
 * }
 * ```
 *
 * Approach #2, using `clearInput`
 * ```
 * when (state) {
 *   ASK_NAME -> text("Your name? "); input()
 *   ASK_AGE -> text("Your age? "); input()
 *   ...
 * }.run {
 *   onInputEntered {
 *      if (state == ASK_NAME) {
 *        name = input
 *        clearInput()
 *        state = ASK_AGE
 *      } else if (state == ASK_AGE) {
 *        ...
 *      }
 *   }
 * }
 * ```
 *
 * @param completer Optional logic for suggesting auto-completions based on what the user typed in. See
 *   [Completions] which is a generally useful and common implementation.
 * @param initialText Text which will be used the first time `input()` is called and ignored subsequently.
 * @param id See docs above for more details. The value of this parameter can be anything - this method simply does an
 *   equality check on it against a previous value.
 */
fun MainRenderScope.input(completer: InputCompleter? = null, initialText: String = "", id: Any = Unit) {
    data.prepareInput(this)
    completer?.let { data[CompleterKey] = it }

    data.get(InputState.Key) {
        if (this.id != id) {
            this.id = id
            text = initialText
            index = initialText.length
        }

        val completion = try {
            completer?.complete(text)
        } catch (ex: Exception) {
            null
        } ?: ""

        // Note: Trailing space as cursor can be put AFTER last character
        val finalText = "$text$completion "

        scopedState { // Make sure color changes don't leak
            for (i in finalText.indices) {
                if (i == text.length && completer != null && completion.isNotEmpty()) {
                    color(completer.color)
                }
                if (i == index && blinkOn) {
                    invert()
                }
                text(finalText[i])
                if (i == index && blinkOn) {
                    clearInvert()
                }
            }
        }
    }
}

class OnKeyPressedScope(val key: Key)

private val KeyPressedJobKey = RunScope.Lifecycle.createKey<Job>()
private val KeyPressedCallbackKey = RunScope.Lifecycle.createKey<OnKeyPressedScope.() -> Unit>()
// Note: We create a separate key here from above to ensure we can trigger the system callback only AFTER the user
// callback was triggered. That's because the system handler may fire a signal which, if sent out too early, could
// result in the user callback not getting a chance to run.
private val SystemKeyPressedCallbackKey = RunScope.Lifecycle.createKey<OnKeyPressedScope.() -> Unit>()

/**
 * Start running a job that collects keypresses and sends them to callbacks.
 *
 * This is a no-op when called after the first time.
 */
private fun ConcurrentScopedData.prepareOnKeyPressed(terminal: Terminal) {
    prepareKeyFlow(terminal)
    tryPut(
        KeyPressedJobKey,
        provideInitialValue = {
            CoroutineScope(Dispatchers.IO).launch {
                getValue(KeyFlowKey).collect { key ->
                    val scope = OnKeyPressedScope(key)
                    get(KeyPressedCallbackKey) { this.invoke(scope) }
                    get(SystemKeyPressedCallbackKey) { this.invoke(scope) }
                }
            }
        },
        dispose = { job -> job.cancel() }
    )
}

/** A handler you can register in a `run` block to intercept keypresses */
fun RunScope.onKeyPressed(listener: OnKeyPressedScope.() -> Unit) {
    data.prepareOnKeyPressed(section.session.terminal)
    if (!data.tryPut(KeyPressedCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onKeyPressed` callback at a time is supported.")
    }
}

/** A `run` block which runs until one of the specified keys is pressed by the user. */
fun Section.runUntilKeyPressed(vararg keys: Key, block: suspend RunScope.() -> Unit = {}) {
    run {
        data.prepareOnKeyPressed(this.section.session.terminal)
        data[SystemKeyPressedCallbackKey] = { if (keys.contains(key)) abort() }
        block()
        CompletableDeferred<Unit>().await() // The only way out of this function is by aborting
    }
}

class OnInputChangedScope(var input: String, val prevInput: String) {
    internal var rejected = false
    fun rejectInput() { rejected = true }
}
private val InputChangedCallbacksKey = RunScope.Lifecycle.createKey<MutableList<OnInputChangedScope.() -> Unit>>()

fun RunScope.onInputChanged(listener: OnInputChangedScope.() -> Unit) {
    data.putIfAbsent(InputChangedCallbacksKey, provideInitialValue = { mutableListOf() }) { add(listener) }
}

class OnInputEnteredScope(val input: String) {
    internal var rejected = false
    fun rejectInput() { rejected = true }
    internal var cleared = false
    /**
     * Make a request to clear the input on the next render pass.
     *
     * This can be useful if you intend to re-use the same input field across multiple passes.
     */
    fun clearInput() { cleared = true }
}
private val InputEnteredCallbackKey = RunScope.Lifecycle.createKey<OnInputEnteredScope.() -> Unit>()

// Note: We create a separate key here from above to ensure we can trigger the system callback only AFTER the user
// callback was triggered. That's because the system handler may fire a signal which, if sent out too early, could
// result in the user callback not getting a chance to run.
private object SystemInputEnteredCallbackKey : ConcurrentScopedData.Key<() -> Unit> {
    override val lifecycle = RunScope.Lifecycle
}

fun RunScope.onInputEntered(listener: OnInputEnteredScope.() -> Unit) {
    if (!data.tryPut(InputEnteredCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onInputEntered` callback at a time is supported.")
    }
}

fun Section.runUntilInputEntered(block: suspend RunScope.() -> Unit = {}) {
    run {
        data[SystemInputEnteredCallbackKey] = { abort() }
        block()
        CompletableDeferred<Unit>().await() // The only way out of this function is by aborting
    }
}